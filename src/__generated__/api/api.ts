// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'http://localhost:8080'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration | undefined;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError' = 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * Type encompassing any value type
 * @export
 * @interface AnyValue
 */
export interface AnyValue {}

/**
 * An argument
 * @export
 * @interface Argument
 */
export interface Argument {
  /**
   *
   * @type {SupportedType}
   * @memberof Argument
   */
  type: SupportedType;
  /**
   * Type encompassing any value type
   * @type {any}
   * @memberof Argument
   */
  value: any;
}

/**
 * An assertion to be included in a test
 * @export
 * @interface Assertion
 */
export interface Assertion {
  /**
   *
   * @type {Array<Argument>}
   * @memberof Assertion
   */
  inputArguments: Array<Argument>;
  /**
   *
   * @type {Argument}
   * @memberof Assertion
   */
  expectedOutput: Argument;
}

/**
 *
 * @export
 * @interface AssertionResult
 */
export interface AssertionResult {
  /**
   *
   * @type {boolean}
   * @memberof AssertionResult
   */
  passed: boolean;
  /**
   *
   * @type {string}
   * @memberof AssertionResult
   */
  text: string;
  /**
   *
   * @type {Array<AssertionResultItems>}
   * @memberof AssertionResult
   */
  items: Array<AssertionResultItems>;
}

/**
 *
 * @export
 * @interface AssertionResultItems
 */
export interface AssertionResultItems {
  /**
   *
   * @type {boolean}
   * @memberof AssertionResultItems
   */
  passed?: boolean;
  /**
   *
   * @type {string}
   * @memberof AssertionResultItems
   */
  message?: string;
}

/**
 *
 * @export
 * @interface CodeValidationReport
 */
export interface CodeValidationReport {
  /**
   *
   * @type {number}
   * @memberof CodeValidationReport
   */
  exerciseId: number;
  /**
   *
   * @type {number}
   * @memberof CodeValidationReport
   */
  exitCode: number;
  /**
   *
   * @type {string}
   * @memberof CodeValidationReport
   */
  message: string;
  /**
   *
   * @type {CodeValidationReportResult}
   * @memberof CodeValidationReport
   */
  result: CodeValidationReportResult;
  /**
   *
   * @type {string}
   * @memberof CodeValidationReport
   */
  stderr: string;
  /**
   *
   * @type {string}
   * @memberof CodeValidationReport
   */
  stdout: string;
  /**
   *
   * @type {boolean}
   * @memberof CodeValidationReport
   */
  timedOut: boolean;
  /**
   *
   * @type {string}
   * @memberof CodeValidationReport
   */
  token: string;
  /**
   *
   * @type {number}
   * @memberof CodeValidationReport
   */
  executionTime: number;
}

/**
 *
 * @export
 * @interface CodeValidationReportResult
 */
export interface CodeValidationReportResult {
  /**
   *
   * @type {CodeValidationReportResultAssertions}
   * @memberof CodeValidationReportResult
   */
  assertions: CodeValidationReportResultAssertions;
  /**
   *
   * @type {boolean}
   * @memberof CodeValidationReportResult
   */
  completed: boolean;
  /**
   *
   * @type {Array<TestCaseResult>}
   * @memberof CodeValidationReportResult
   */
  output: Array<TestCaseResult>;
}

/**
 *
 * @export
 * @interface CodeValidationReportResultAssertions
 */
export interface CodeValidationReportResultAssertions {
  /**
   *
   * @type {number}
   * @memberof CodeValidationReportResultAssertions
   */
  passed?: number;
  /**
   *
   * @type {number}
   * @memberof CodeValidationReportResultAssertions
   */
  failed?: number;
}

/**
 *
 * @export
 * @interface Credentials
 */
export interface Credentials {
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  password: string;
}

/**
 * Exercise difficulty range
 * @export
 * @enum {string}
 */
export enum Difficulties {
  EASY = 'EASY',
  MEDIUM = 'MEDIUM',
  HARD = 'HARD',
}

/**
 *
 * @export
 * @interface Exercise
 */
export interface Exercise {
  /**
   *
   * @type {number}
   * @memberof Exercise
   */
  id: number;
  /**
   *
   * @type {IntlString}
   * @memberof Exercise
   */
  title: IntlString;
  /**
   *
   * @type {IntlString}
   * @memberof Exercise
   */
  description: IntlString;
  /**
   *
   * @type {Difficulties}
   * @memberof Exercise
   */
  difficulty: Difficulties;
  /**
   *
   * @type {Template}
   * @memberof Exercise
   */
  template: Template;
  /**
   *
   * @type {ExerciseFixtures}
   * @memberof Exercise
   */
  fixtures: ExerciseFixtures;
  /**
   *
   * @type {Array<TestCase>}
   * @memberof Exercise
   */
  sampleTestCases: Array<TestCase>;
}

/**
 *
 * @export
 * @interface ExerciseFixtures
 */
export interface ExerciseFixtures {
  /**
   *
   * @type {Array<string>}
   * @memberof ExerciseFixtures
   */
  cpp?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ExerciseFixtures
   */
  python?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ExerciseFixtures
   */
  java?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ExerciseFixtures
   */
  javascript?: Array<string>;
}

/**
 *
 * @export
 * @interface ExerciseSubmission
 */
export interface ExerciseSubmission {
  /**
   *
   * @type {number}
   * @memberof ExerciseSubmission
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof ExerciseSubmission
   */
  exerciseId: number;
  /**
   *
   * @type {number}
   * @memberof ExerciseSubmission
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof ExerciseSubmission
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ExerciseSubmission
   */
  language: string;
  /**
   *
   * @type {Date}
   * @memberof ExerciseSubmission
   */
  createdAt?: Date;
}

/**
 * Group of students
 * @export
 * @interface Group
 */
export interface Group {
  /**
   *
   * @type {number}
   * @memberof Group
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof Group
   */
  groupNumber: number;
  /**
   *
   * @type {string}
   * @memberof Group
   */
  course: string;
  /**
   *
   * @type {Semesters}
   * @memberof Group
   */
  semester: Semesters;
  /**
   *
   * @type {number}
   * @memberof Group
   */
  year: number;
  /**
   *
   * @type {Array<Student>}
   * @memberof Group
   */
  students: Array<Student>;
  /**
   *
   * @type {boolean}
   * @memberof Group
   */
  archived: boolean;
}

/**
 *
 * @export
 * @interface IntlString
 */
export interface IntlString {
  /**
   *
   * @type {string}
   * @memberof IntlString
   */
  fr: string;
  /**
   *
   * @type {string}
   * @memberof IntlString
   */
  en?: string;
}

/**
 * A parameter
 * @export
 * @interface Parameter
 */
export interface Parameter {
  /**
   *
   * @type {string}
   * @memberof Parameter
   */
  name: string;
  /**
   *
   * @type {SupportedType}
   * @memberof Parameter
   */
  type: SupportedType;
}

/**
 *
 * @export
 * @interface RFC7807Body
 */
export interface RFC7807Body {
  /**
   *
   * @type {string}
   * @memberof RFC7807Body
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof RFC7807Body
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof RFC7807Body
   */
  detail?: string;
  /**
   *
   * @type {number}
   * @memberof RFC7807Body
   */
  status?: number;
  /**
   *
   * @type {string}
   * @memberof RFC7807Body
   */
  instance?: string;
}

/**
 *
 * @export
 * @interface RunnerArguments
 */
export interface RunnerArguments {
  /**
   * code
   * @type {string}
   * @memberof RunnerArguments
   */
  code?: string;
  /**
   * language
   * @type {string}
   * @memberof RunnerArguments
   */
  language?: string;
  /**
   * fixture
   * @type {string}
   * @memberof RunnerArguments
   */
  fixture?: string;
}

/**
 * Semester values.
 * @export
 * @enum {string}
 */
export enum Semesters {
  FALL = 'FALL',
  WINTER = 'WINTER',
  SUMMER = 'SUMMER',
}

/**
 * A student user
 * @export
 * @interface Student
 */
export interface Student {
  /**
   *
   * @type {number}
   * @memberof Student
   */
  accessCode: number;
  /**
   *
   * @type {number}
   * @memberof Student
   */
  firstName: number;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  email?: string;
  /**
   *
   * @type {number}
   * @memberof Student
   */
  totalExercisesSuccessed?: number;
  /**
   *
   * @type {number}
   * @memberof Student
   */
  totalExercisesDone?: number;
}

/**
 * Languages supported by the api
 * @export
 * @enum {string}
 */
export enum SupportedLanguages {
  Cpp = 'cpp',
  Java = 'java',
  Javascript = 'javascript',
  Python = 'python',
}

/**
 *
 * @export
 * @enum {string}
 */
export enum SupportedType {
  BOOLEAN = 'BOOLEAN',
  INT = 'INT',
  FLOAT = 'FLOAT',
  STRING = 'STRING',
  CHAR = 'CHAR',
  BOOLEANARRAY = 'BOOLEAN_ARRAY',
  INTARRAY = 'INT_ARRAY',
  FLOATARRAY = 'FLOAT_ARRAY',
  STRINGARRAY = 'STRING_ARRAY',
  CHARARRAY = 'CHAR_ARRAY',
}

/**
 *
 * @export
 * @interface Template
 */
export interface Template {
  /**
   *
   * @type {string}
   * @memberof Template
   */
  className?: string;
  /**
   *
   * @type {string}
   * @memberof Template
   */
  functionName: string;
  /**
   *
   * @type {Array<Parameter>}
   * @memberof Template
   */
  params: Array<Parameter>;
  /**
   *
   * @type {SupportedType}
   * @memberof Template
   */
  functionReturnType: SupportedType;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Template
   */
  prependedCode: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Template
   */
  appendedCode: { [key: string]: string };
}

/**
 * Test case data structure used to generate examplary test cases
 * @export
 * @interface TestCase
 */
export interface TestCase {
  /**
   *
   * @type {string}
   * @memberof TestCase
   */
  it: string;
  /**
   *
   * @type {Array<Assertion>}
   * @memberof TestCase
   */
  assertions: Array<Assertion>;
}

/**
 *
 * @export
 * @interface TestCaseResult
 */
export interface TestCaseResult {
  /**
   *
   * @type {boolean}
   * @memberof TestCaseResult
   */
  passed: boolean;
  /**
   *
   * @type {string}
   * @memberof TestCaseResult
   */
  text: string;
  /**
   *
   * @type {Array<AssertionResult>}
   * @memberof TestCaseResult
   */
  items: Array<AssertionResult>;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  password: string;
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function(
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Creates a new exercise
     * @param {Exercise} exercise
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesAdd(exercise: Exercise, options: any = {}): FetchArgs {
      // verify required parameter 'exercise' is not null or undefined
      if (exercise === null || exercise === undefined) {
        throw new RequiredError(
          'exercise',
          'Required parameter exercise was null or undefined when calling exercisesAdd.',
        );
      }
      const localVarPath = `/exercises`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'Exercise' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(exercise || {})
        : exercise || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the specified exercise
     * @param {number} exerciseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdGet(exerciseId: number, options: any = {}): FetchArgs {
      // verify required parameter 'exerciseId' is not null or undefined
      if (exerciseId === null || exerciseId === undefined) {
        throw new RequiredError(
          'exerciseId',
          'Required parameter exerciseId was null or undefined when calling exercisesExerciseIdGet.',
        );
      }
      const localVarPath = `/exercises/{exerciseId}`.replace(
        `{${'exerciseId'}}`,
        encodeURIComponent(String(exerciseId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsGet(
      exerciseId: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'exerciseId' is not null or undefined
      if (exerciseId === null || exerciseId === undefined) {
        throw new RequiredError(
          'exerciseId',
          'Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsGet.',
        );
      }
      const localVarPath = `/exercises/{exerciseId}/submissions`.replace(
        `{${'exerciseId'}}`,
        encodeURIComponent(String(exerciseId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submits the code as the current user's solution for the exercise
     * @param {number} exerciseId
     * @param {ExerciseSubmission} exerciseSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsPost(
      exerciseId: number,
      exerciseSubmission: ExerciseSubmission,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'exerciseId' is not null or undefined
      if (exerciseId === null || exerciseId === undefined) {
        throw new RequiredError(
          'exerciseId',
          'Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsPost.',
        );
      }
      // verify required parameter 'exerciseSubmission' is not null or undefined
      if (exerciseSubmission === null || exerciseSubmission === undefined) {
        throw new RequiredError(
          'exerciseSubmission',
          'Required parameter exerciseSubmission was null or undefined when calling exercisesExerciseIdSubmissionsPost.',
        );
      }
      const localVarPath = `/exercises/{exerciseId}/submissions`.replace(
        `{${'exerciseId'}}`,
        encodeURIComponent(String(exerciseId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ExerciseSubmission' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(exerciseSubmission || {})
        : exerciseSubmission || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId
     * @param {number} submissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsSubmissionIdGet(
      exerciseId: number,
      submissionId: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'exerciseId' is not null or undefined
      if (exerciseId === null || exerciseId === undefined) {
        throw new RequiredError(
          'exerciseId',
          'Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdGet.',
        );
      }
      // verify required parameter 'submissionId' is not null or undefined
      if (submissionId === null || submissionId === undefined) {
        throw new RequiredError(
          'submissionId',
          'Required parameter submissionId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdGet.',
        );
      }
      const localVarPath = `/exercises/{exerciseId}/submissions/{submissionId}`
        .replace(`{${'exerciseId'}}`, encodeURIComponent(String(exerciseId)))
        .replace(
          `{${'submissionId'}}`,
          encodeURIComponent(String(submissionId)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the results of the exercise validation for this submission
     * @param {number} exerciseId
     * @param {number} submissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
      exerciseId: number,
      submissionId: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'exerciseId' is not null or undefined
      if (exerciseId === null || exerciseId === undefined) {
        throw new RequiredError(
          'exerciseId',
          'Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdResultsGet.',
        );
      }
      // verify required parameter 'submissionId' is not null or undefined
      if (submissionId === null || submissionId === undefined) {
        throw new RequiredError(
          'submissionId',
          'Required parameter submissionId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdResultsGet.',
        );
      }
      const localVarPath = `/exercises/{exerciseId}/submissions/{submissionId}/results`
        .replace(`{${'exerciseId'}}`, encodeURIComponent(String(exerciseId)))
        .replace(
          `{${'submissionId'}}`,
          encodeURIComponent(String(submissionId)),
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validate the code against the user-provided test suite
     * @param {number} exerciseId
     * @param {RunnerArguments} runnerArguments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdTestPost(
      exerciseId: number,
      runnerArguments: RunnerArguments,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'exerciseId' is not null or undefined
      if (exerciseId === null || exerciseId === undefined) {
        throw new RequiredError(
          'exerciseId',
          'Required parameter exerciseId was null or undefined when calling exercisesExerciseIdTestPost.',
        );
      }
      // verify required parameter 'runnerArguments' is not null or undefined
      if (runnerArguments === null || runnerArguments === undefined) {
        throw new RequiredError(
          'runnerArguments',
          'Required parameter runnerArguments was null or undefined when calling exercisesExerciseIdTestPost.',
        );
      }
      const localVarPath = `/exercises/{exerciseId}/test`.replace(
        `{${'exerciseId'}}`,
        encodeURIComponent(String(exerciseId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'RunnerArguments' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(runnerArguments || {})
        : runnerArguments || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the full list of exercises
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesIndex(options: any = {}): FetchArgs {
      const localVarPath = `/exercises`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsAdd(group: Group, options: any = {}): FetchArgs {
      // verify required parameter 'group' is not null or undefined
      if (group === null || group === undefined) {
        throw new RequiredError(
          'group',
          'Required parameter group was null or undefined when calling groupsAdd.',
        );
      }
      const localVarPath = `/groups`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'Group' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(group || {})
        : group || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the full list of groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowse(options: any = {}): FetchArgs {
      const localVarPath = `/groups`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edits an existing group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsEdit(group: Group, options: any = {}): FetchArgs {
      // verify required parameter 'group' is not null or undefined
      if (group === null || group === undefined) {
        throw new RequiredError(
          'group',
          'Required parameter group was null or undefined when calling groupsEdit.',
        );
      }
      const localVarPath = `/groups`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'PUT' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'Group' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(group || {})
        : group || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the specified user's reports
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userReportsRead(userId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling userReportsRead.',
        );
      }
      const localVarPath = `/users/{userId}/reports`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new user
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersAdd(user: User, options: any = {}): FetchArgs {
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          'user',
          'Required parameter user was null or undefined when calling usersAdd.',
        );
      }
      const localVarPath = `/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'POST' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'User' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(user || {})
        : user || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the full list of users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersBrowse(options: any = {}): FetchArgs {
      const localVarPath = `/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the specified user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRead(userId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling usersRead.',
        );
      }
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = Object.assign(
        { method: 'GET' },
        baseOptions,
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarHeaderParameter['Authorization'] =
          'Basic ' +
          btoa(configuration.username + ':' + configuration.password);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates a new exercise
     * @param {Exercise} exercise
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesAdd(
      exercise: Exercise,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Exercise> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesAdd(exercise, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the specified exercise
     * @param {number} exerciseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdGet(
      exerciseId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Exercise> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesExerciseIdGet(exerciseId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsGet(
      exerciseId: number,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<ExerciseSubmission>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesExerciseIdSubmissionsGet(exerciseId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Submits the code as the current user's solution for the exercise
     * @param {number} exerciseId
     * @param {ExerciseSubmission} exerciseSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsPost(
      exerciseId: number,
      exerciseSubmission: ExerciseSubmission,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesExerciseIdSubmissionsPost(
        exerciseId,
        exerciseSubmission,
        options,
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId
     * @param {number} submissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsSubmissionIdGet(
      exerciseId: number,
      submissionId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ExerciseSubmission> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesExerciseIdSubmissionsSubmissionIdGet(
        exerciseId,
        submissionId,
        options,
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the results of the exercise validation for this submission
     * @param {number} exerciseId
     * @param {number} submissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
      exerciseId: number,
      submissionId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CodeValidationReport> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
        exerciseId,
        submissionId,
        options,
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Validate the code against the user-provided test suite
     * @param {number} exerciseId
     * @param {RunnerArguments} runnerArguments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdTestPost(
      exerciseId: number,
      runnerArguments: RunnerArguments,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CodeValidationReport> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesExerciseIdTestPost(exerciseId, runnerArguments, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the full list of exercises
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesIndex(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Exercise>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).exercisesIndex(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Creates a new group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsAdd(
      group: Group,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Group> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).groupsAdd(group, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the full list of groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowse(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Group>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).groupsBrowse(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Edits an existing group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsEdit(
      group: Group,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Group> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).groupsEdit(group, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the specified user's reports
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userReportsRead(
      userId: number,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<CodeValidationReport>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).userReportsRead(userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Creates a new user
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersAdd(
      user: User,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).usersAdd(user, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the full list of users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersBrowse(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).usersBrowse(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the specified user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRead(
      userId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).usersRead(userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Creates a new exercise
     * @param {Exercise} exercise
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesAdd(exercise: Exercise, options?: any) {
      return DefaultApiFp(configuration).exercisesAdd(exercise, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Gets the specified exercise
     * @param {number} exerciseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdGet(exerciseId: number, options?: any) {
      return DefaultApiFp(configuration).exercisesExerciseIdGet(
        exerciseId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsGet(exerciseId: number, options?: any) {
      return DefaultApiFp(configuration).exercisesExerciseIdSubmissionsGet(
        exerciseId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Submits the code as the current user's solution for the exercise
     * @param {number} exerciseId
     * @param {ExerciseSubmission} exerciseSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsPost(
      exerciseId: number,
      exerciseSubmission: ExerciseSubmission,
      options?: any,
    ) {
      return DefaultApiFp(configuration).exercisesExerciseIdSubmissionsPost(
        exerciseId,
        exerciseSubmission,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId
     * @param {number} submissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsSubmissionIdGet(
      exerciseId: number,
      submissionId: number,
      options?: any,
    ) {
      return DefaultApiFp(
        configuration,
      ).exercisesExerciseIdSubmissionsSubmissionIdGet(
        exerciseId,
        submissionId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets the results of the exercise validation for this submission
     * @param {number} exerciseId
     * @param {number} submissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
      exerciseId: number,
      submissionId: number,
      options?: any,
    ) {
      return DefaultApiFp(
        configuration,
      ).exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
        exerciseId,
        submissionId,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Validate the code against the user-provided test suite
     * @param {number} exerciseId
     * @param {RunnerArguments} runnerArguments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesExerciseIdTestPost(
      exerciseId: number,
      runnerArguments: RunnerArguments,
      options?: any,
    ) {
      return DefaultApiFp(configuration).exercisesExerciseIdTestPost(
        exerciseId,
        runnerArguments,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets the full list of exercises
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exercisesIndex(options?: any) {
      return DefaultApiFp(configuration).exercisesIndex(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Creates a new group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsAdd(group: Group, options?: any) {
      return DefaultApiFp(configuration).groupsAdd(group, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Gets the full list of groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowse(options?: any) {
      return DefaultApiFp(configuration).groupsBrowse(options)(fetch, basePath);
    },
    /**
     *
     * @summary Edits an existing group
     * @param {Group} group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsEdit(group: Group, options?: any) {
      return DefaultApiFp(configuration).groupsEdit(group, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Gets the specified user's reports
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userReportsRead(userId: number, options?: any) {
      return DefaultApiFp(configuration).userReportsRead(userId, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Creates a new user
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersAdd(user: User, options?: any) {
      return DefaultApiFp(configuration).usersAdd(user, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Gets the full list of users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersBrowse(options?: any) {
      return DefaultApiFp(configuration).usersBrowse(options)(fetch, basePath);
    },
    /**
     *
     * @summary Gets the specified user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRead(userId: number, options?: any) {
      return DefaultApiFp(configuration).usersRead(userId, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   *
   * @summary Creates a new exercise
   * @param {Exercise} exercise
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesAdd(exercise: Exercise, options?: any): Promise<Exercise>;

  /**
   *
   * @summary Gets the specified exercise
   * @param {number} exerciseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesExerciseIdGet(exerciseId: number, options?: any): Promise<Exercise>;

  /**
   *
   * @summary Gets the list of submissions for the specified exercise
   * @param {number} exerciseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesExerciseIdSubmissionsGet(
    exerciseId: number,
    options?: any,
  ): Promise<Array<ExerciseSubmission>>;

  /**
   *
   * @summary Submits the code as the current user's solution for the exercise
   * @param {number} exerciseId
   * @param {ExerciseSubmission} exerciseSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesExerciseIdSubmissionsPost(
    exerciseId: number,
    exerciseSubmission: ExerciseSubmission,
    options?: any,
  ): Promise<{}>;

  /**
   *
   * @summary Gets the list of submissions for the specified exercise
   * @param {number} exerciseId
   * @param {number} submissionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesExerciseIdSubmissionsSubmissionIdGet(
    exerciseId: number,
    submissionId: number,
    options?: any,
  ): Promise<ExerciseSubmission>;

  /**
   *
   * @summary Gets the results of the exercise validation for this submission
   * @param {number} exerciseId
   * @param {number} submissionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
    exerciseId: number,
    submissionId: number,
    options?: any,
  ): Promise<CodeValidationReport>;

  /**
   *
   * @summary Validate the code against the user-provided test suite
   * @param {number} exerciseId
   * @param {RunnerArguments} runnerArguments
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesExerciseIdTestPost(
    exerciseId: number,
    runnerArguments: RunnerArguments,
    options?: any,
  ): Promise<CodeValidationReport>;

  /**
   *
   * @summary Gets the full list of exercises
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  exercisesIndex(options?: any): Promise<Array<Exercise>>;

  /**
   *
   * @summary Creates a new group
   * @param {Group} group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  groupsAdd(group: Group, options?: any): Promise<Group>;

  /**
   *
   * @summary Gets the full list of groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  groupsBrowse(options?: any): Promise<Array<Group>>;

  /**
   *
   * @summary Edits an existing group
   * @param {Group} group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  groupsEdit(group: Group, options?: any): Promise<Group>;

  /**
   *
   * @summary Gets the specified user's reports
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  userReportsRead(
    userId: number,
    options?: any,
  ): Promise<Array<CodeValidationReport>>;

  /**
   *
   * @summary Creates a new user
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  usersAdd(user: User, options?: any): Promise<User>;

  /**
   *
   * @summary Gets the full list of users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  usersBrowse(options?: any): Promise<Array<User>>;

  /**
   *
   * @summary Gets the specified user
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  usersRead(userId: number, options?: any): Promise<User>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   *
   * @summary Creates a new exercise
   * @param {Exercise} exercise
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesAdd(exercise: Exercise, options?: any) {
    return DefaultApiFp(this.configuration).exercisesAdd(exercise, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Gets the specified exercise
   * @param {number} exerciseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesExerciseIdGet(exerciseId: number, options?: any) {
    return DefaultApiFp(this.configuration).exercisesExerciseIdGet(
      exerciseId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets the list of submissions for the specified exercise
   * @param {number} exerciseId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesExerciseIdSubmissionsGet(exerciseId: number, options?: any) {
    return DefaultApiFp(this.configuration).exercisesExerciseIdSubmissionsGet(
      exerciseId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Submits the code as the current user's solution for the exercise
   * @param {number} exerciseId
   * @param {ExerciseSubmission} exerciseSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesExerciseIdSubmissionsPost(
    exerciseId: number,
    exerciseSubmission: ExerciseSubmission,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration).exercisesExerciseIdSubmissionsPost(
      exerciseId,
      exerciseSubmission,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets the list of submissions for the specified exercise
   * @param {number} exerciseId
   * @param {number} submissionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesExerciseIdSubmissionsSubmissionIdGet(
    exerciseId: number,
    submissionId: number,
    options?: any,
  ) {
    return DefaultApiFp(
      this.configuration,
    ).exercisesExerciseIdSubmissionsSubmissionIdGet(
      exerciseId,
      submissionId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets the results of the exercise validation for this submission
   * @param {number} exerciseId
   * @param {number} submissionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
    exerciseId: number,
    submissionId: number,
    options?: any,
  ) {
    return DefaultApiFp(
      this.configuration,
    ).exercisesExerciseIdSubmissionsSubmissionIdResultsGet(
      exerciseId,
      submissionId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Validate the code against the user-provided test suite
   * @param {number} exerciseId
   * @param {RunnerArguments} runnerArguments
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesExerciseIdTestPost(
    exerciseId: number,
    runnerArguments: RunnerArguments,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration).exercisesExerciseIdTestPost(
      exerciseId,
      runnerArguments,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets the full list of exercises
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public exercisesIndex(options?: any) {
    return DefaultApiFp(this.configuration).exercisesIndex(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Creates a new group
   * @param {Group} group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public groupsAdd(group: Group, options?: any) {
    return DefaultApiFp(this.configuration).groupsAdd(group, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Gets the full list of groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public groupsBrowse(options?: any) {
    return DefaultApiFp(this.configuration).groupsBrowse(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Edits an existing group
   * @param {Group} group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public groupsEdit(group: Group, options?: any) {
    return DefaultApiFp(this.configuration).groupsEdit(group, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Gets the specified user's reports
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userReportsRead(userId: number, options?: any) {
    return DefaultApiFp(this.configuration).userReportsRead(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Creates a new user
   * @param {User} user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public usersAdd(user: User, options?: any) {
    return DefaultApiFp(this.configuration).usersAdd(user, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Gets the full list of users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public usersBrowse(options?: any) {
    return DefaultApiFp(this.configuration).usersBrowse(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Gets the specified user
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public usersRead(userId: number, options?: any) {
    return DefaultApiFp(this.configuration).usersRead(userId, options)(
      this.fetch,
      this.basePath,
    );
  }
}
